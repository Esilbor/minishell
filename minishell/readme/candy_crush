
free_shell = free (paths, envp, set + cmd_struct_tab, readline input)
cmd_struct_tab = free (cmd, eof, input_redir, output, heredoc_path, cmd_struct_tab)

candy_crush = free (env_lst, envp, paths + cmd_struct_tab + set)
            =   free_shell + env_lst

close_and_crush = pipe, pid + candy_crush



void	free_cmd_struct_tab(t_cmd **cmd_struct_tab);

void	free_shell(t_set *set, char *input, t_cmd **cmd_struct_tab);

void	ft_close_and_free(t_set *set);

void	candy_crush(t_set *set);

execution > free_shell

pipe
pid

void	close_and_crush(t_set *set, int do_exit, int exit_ret)
{
	ft_close_and_free(set);
	ft_free_tab((void **)set->pid);
	candy_crush(set);
	if (do_exit)
		exit(exit_ret);
}

ft_pipex

les child doivent exit puis le parent doit aussi close_and_crush?

il faut open les input en totalite avant >


apres le parsing creer les heredoc et ouvrir les inputs de tel facon qu'a lexec open n'est qu'a ouvrir les input.'





*************HEREDOCS*****************


void	ft_heredoc_create(t_data *data, int i, char *file_name, int fd)
{
	char	*buf;

	fd = open(file_name, O_WRONLY | O_TRUNC | O_CREAT, 0644);
	if (fd < 0)
		ft_error_msn("An error occured with open of here_doc\n", data);
	while (1)
	{
		ft_signal_interactive();
		buf = readline("heredoc> ");
		ft_signal_noninteractive();
		if (!buf)
		{
			printf("\n");
			break ;
		}
		if (buf || buf[0])
		{
			if (!ft_strcmp(data->cmds[i]->eof, buf))
				break ;
			write(fd, buf, ft_strlen(buf));
			write(fd, "\n", 1);
		}
		free(buf);
	}
	close(fd);
}

void	ft_heredoc_path(t_data *data, int i)
{
	char	*tmp;
	int		j;

	j = i + 1;
	if (data->cmds[i]->eof)
	{
		tmp = ft_itoa(j);
		data->cmds[i]->heredoc_path
			= ft_strjoin_gnl(".build/.heredoc", tmp);
		free(tmp);
		if (!data->cmds[i]->heredoc_path)
			ft_error_msn("Invalid Malloc here_doc path\n", data);
	}
}

int	here_doc(char *limiter)
{
	int        fd_in;
	int        fd_out;
	char    *line;

	fd_in = open("/dev/stdin", O_RDONLY);
	fd_out = open(".here_doc", O_WRONLY | O_CREAT | O_TRUNC, 0644);
	prompt();
	while (1)
	{
		line = get_next_line(fd_in); // readline
		if (ft_strncmp(line, limiter, ft_strlen(limiter)) == 0 && ft_strlen(limiter) == ft_strlen(line))
			break ;
		else
		{
			if (write(fd_out, line, ft_strlen(line)) != ft_strlen(line))
				return (-1);
		}
		prompt();
	}
	free(line);
	close(fd_in);
	close(fd_out);
	return (0);
}
